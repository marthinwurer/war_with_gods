#ifndef COMPONENT_H
#define COMPONENT_H

#include "entity.h"

#include <cstdint>
#include <memory>
#include <set>
#include <unordered_map>

#define INVALID_COMPONENT 0

/**
 * @brief All components should inherit the Component struct and define a 
 * unique m_type.
 */
struct Component {
    static const uint32_t m_type = INVALID_COMPONENT;
};

/**
 * @brief A generic interface for all ComponentStores generated by the class 
 * template to inherit.
 * 
 * @todo Either rename the smart pointer typedef or get rid of it.
 */
class IComponentStore {
public:
    typedef std::unique_ptr<IComponentStore> Ptr;
};

/**
 * @brief Handles storage of a specific component type
 * 
 * @tparam C The Component of the store
 */
template<class C>
class ComponentStore: public IComponentStore {
    static_assert(std::is_base_of<Component, C>::value, "C must be derived from the Component struct");
    static_assert(C::m_type != INVALID_COMPONENT, "C must define a valid non-zero m_type");

private:
    std::unordered_map<Entity, C> m_store;
    static const uint32_t m_type = C::m_type;

public:
    /**
     * @brief Associates a component with an entity by adding it to the store. 
     * 
     * @param entity        Entity to add to the store.
     * @param component     Component to addd to the store.
     * @return true         If the entity was successfully added.
     * @return false        If the entity already exists or adding the entity failed.
     */
    bool add(const Entity entity, C&& component) {
        return m_store.insert(std::make_pair(entity, std::move(component))).second;
    }

    /**
     * @brief Removes an entity from the store.
     *  
     * @param entity    Entity to remove from the store.
     * @return true     If the entity was sucessfully removed
     * @return false    If the entity does not already exists.
     */
    bool remove(Entity entity) {
        return (0 < m_store.erase(entity));
    }

    /**
     * @brief Determines if the store has a specific entity.
     * 
     * @param entity    Entity to check for.
     * @return true     If the store contains the specified entity.
     * @return false    If the store does not contain the specified entity.
     */
    bool has(Entity entity) const {
        return (m_store.end() != m_store.find(entity));
    }

    /**
     * @brief Gets a specific component.
     * 
     * @param entity    Entity to get the component for. 
     * @return C&       The component of the specified entity.
     */
    C& get(Entity entity) {
        return m_store.at(entity);
    }

    /**
     * @brief Returns the store.
     * 
     * @return const std::unordered_map<Entity, C>&     The store of type C
     */
    const std::unordered_map<Entity, C>& components() {
        return m_store;
    }
};

#endif